---
layout: post
title:  "Paper Review - 4"
---

The papers for this week:

1. Taha's paper: W Taha, A Gentle Introduction to Multi-stage
   Programming, DSPG'04.
2. Oleg's paper: A Methodology for Generating Verified Combinatorial
   Circuits, EMSOFT'04.

1.Taha's paper
--------------

MetaOCaml's approach to multi-stage programming (MSP) has already been
reviewed through the eponymous TCS'00 paper. The current paper is a
tutorial-style introduction to MSP via MetaOCaml. It outlines a
step-by-step method to build a multi-stage program from a single-stage
program that can be summarized by the slogan: A Staged Program = A
Conventional Program + Staging Annotations. The paper demonstrates
this method through an example interpreter for a simple language. The
language is defined by representing its AST as a data structure in
OCaml. A meta-circular interpreter for the language, which interprets
programs in the language by repeatedly traversing the AST is written.
At this point, we have correct, albeit inefficient, single-stage code.
It is now observed that the program can be factored into two stages.
The entire AST data structure and the interpreter belong to first stage.
The interpreter runs and produces OCaml code that is equivalent to
AST. This code belongs to first stage. This effectively makes the
staged interpreter a translator from AST to effecient OCaml code.

However, this generated code may not be efficient for all
interpreters. For example, the straightforward staged interpreter for
the simple language extended with explicit error handling via option
types generates code that is much slower. However, the paper suggests
CPS transformation as a way to fix this. The basic idea is to push the
option type to first level so that it is no longer there in the
generated code (i.e., staged CPS interpreter generates a int code
option instead of int option code). To further improve the performance
of the generated code, the paper suggests:
1. Controlled inlining by unfolding a recursive function a fixed
   number of times, and 
2. Using "let" bindings to avoid code duplication in the generated
   code.
The paper ends with a illustrative comparision of staged interpreters
with aforementioned optimizations. The conclusion is that with CPS
transformation and inlining, the code generated by the multi-stage
interpreter for the programs with error handling can be faster than
their OCaml implementations.
 
2.Oleg's paper
--------------

Recall the power function written in MetaOCaml. Let us consider a
case where we want to do certain optimizations on the generated code.
For example, we would like to remove the unnecessary multiplication
with 1. Unfortunately, it is not possible to specify such optimization
along with the staged power function, as it is not possible for the
staged program to inspect the generated code. In this paper, Oleg et
al propose a solution to this problem. The idea is to refine the type
of code to capture more information about the kind of values it 
generates. For example, instead of merely representing the type of
integer generating code as int code, we can instead record its type as
a sum type that distinguishes between the value 1 from rest of the
integers. Any operation on this type can define special behaviours
tailor-made for case when one of the values is 1. This lets us specify
optimizations on the generated code without actually accessing the
generated code. It should be noted that this is one of the central
ideas guiding Scala's lightweight modular staging approach. 

Oleg's paper demonstrates the effectiveness of the abstract
interpretation approach in performing domain-specific optimizations
for the usecase of a multi-stage verified circuit generator for fast
fourier transform (FFT). For instance, the paper shows how an
abstract type for float expressions that can distinguish between
literals and compound expressions can be used to perform constant
folding in expensive floating point operations such as
multiplications. Emperical results show that there is significant
reduction in number of floating point multiplications when compared to
staged FFT without abstract interpretation. 

<!--
Resource-aware Programming (RAP) applies the idea of multi-stage
programming to write verified high-level generators for low-level
combinatorial circuits. A verified generator essentially means that
the circuits it generates are "correct by construction" pre-empting
the need to explicitly verify them. Further, circuit generators
written as multi-staged programs clearly distinguish between
computation done on the development platform (i.e., by the generator),
and computation done on the deployment platform (i.e., by the
generated circuit). This allows optimizing for performance on
deployment platform by performing as much computation as possible on
development platform. -->

